# -*- coding: utf-8 -*-
"""RESNET18.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mcw4dxchbyAiim-xYd9qd0Er9jIfl409
"""

from torchvision.datasets import ImageFolder
import matplotlib.pyplot as plt
import torch
from torchvision import transforms, datasets
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision
import numpy as np

transforms = transforms.Compose([
    transforms.Resize(256),    
    transforms.CenterCrop(224),   
    transforms.ToTensor(),       
])

# from google.colab import drive
# drive.mount('/content/drive')

# path = r'/content/drive/MyDrive/project twit/aws/data/FSL'

path = r'/home/ubuntu/efs/data/FSL'

# import matplotlib.pyplot as plt
import numpy as np
# import seaborn as sns
import torch
import torchvision

# Set the device
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# Set the batch size and number of epochs
batch_size = 1 #12
num_epochs = 1 #100

data_train = datasets.ImageFolder(path, transform=transforms)
 
data_loader = DataLoader(data_train, batch_size=batch_size, shuffle=True)

# Define the RESNET model
model=torchvision.models.resnet18(pretrained=True)
for para in model.parameters():
    para.require_grad=False
model.fc=torch.nn.Linear(512,2)


# Set the model in training mode
model.train()

# Move the model to the device
model.to(device)

# Define the loss function and optimizer
loss_fn = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters())

# Set the training loss list
train_losses = []

# Set the training accuracy list
train_accuracies = []

# Train the model
for epoch in range(num_epochs):
    if(epoch%10==0):
        print(f'{epoch}',end=' ')
    # Set the running training loss
    running_train_loss = 0.0
    
    # Set the running training accuracy
    running_train_accuracy = 0.0
    
    # Loop through the training set
    for i, (images, labels) in enumerate(data_loader):
        # Move the images and labels to the device
        images = images.to(device)
        labels = labels.to(device)
        
        # Make a prediction on the images
        predictions = model(images)
        
        # Calculate the loss
        loss = loss_fn(predictions, labels)
        
        # Zero the gradients
        optimizer.zero_grad()
        
        # Backpropagate the loss
        loss.backward()
        
        # Update the weights
        optimizer.step()
        
        # Get the predicted classes
        _, predicted_classes = torch.max(predictions, dim=1)
        
        # Calculate the accuracy
        accuracy = (predicted_classes == labels).float().mean().item()
        
        # Update the running training loss and accuracy
        running_train_loss += loss.item()
        running_train_accuracy += accuracy
        
    # Calculate the average training loss and accuracy
    train_loss = running_train_loss / len(data_loader)
    train_losses.append(train_loss)
    train_accuracy = running_train_accuracy / len(data_loader)
    train_accuracies.append(train_accuracy)
    if(epoch%10==0):
        print(f'train_loss:{train_loss}',end='  ')
        print(f'train_accuracy:{train_accuracy}')

import os
os.environ["KMP_DUPLICATE_LIB_OK"]="TRUE"
plt.figure()
plt.plot(train_losses)
plt.plot(train_accuracies)
plt.legend(['train_losses','train_accuracies'])
plt.xlabel('epoch')
plt.title("Resnet18")
plt.savefig("resnet18_plot.png", bbox_inches="tight", dpi=300)
plt.grid()

model.eval()
true_labels = []
pred_labels = []
for i, (images, labels) in enumerate(data_loader):
    # Move the images and labels to the device
    images = images.to(device)
    labels = labels.to(device)
        
    # Make predictions
    outputs = model(images)
    _, preds = torch.max(outputs, dim=1)

    # Save the true labels and predicted labels
    true_labels.extend(labels.tolist())
    pred_labels.extend(preds.tolist())

len(true_labels)

from sklearn.metrics import confusion_matrix, f1_score, accuracy_score, recall_score, roc_auc_score, roc_curve
import pandas as pd

confusion_matrix = confusion_matrix(true_labels, pred_labels)
pd.DataFrame(confusion_matrix)
import seaborn as sns

sns.heatmap(confusion_matrix,annot=True,)
plt.title("Resnet18_confusion_matrix")
plt.savefig("resnet18_confusion_matrix.png", bbox_inches="tight", dpi=300)
plt.show()

f1 = f1_score(true_labels, pred_labels)
print(f1)

accuracy = accuracy_score(true_labels, pred_labels)
print(accuracy)

recall = recall_score(true_labels, pred_labels)
print(recall)

auc = roc_auc_score(true_labels, pred_labels)
print(auc)

fpr, tpr, thresholds = roc_curve(true_labels, pred_labels)
plt.plot(fpr, tpr, "b-", label="ROC curve")
plt.plot([0, 1], [0, 1], "k--", label="random guess")
plt.xlabel("False Positive Rate (Fall-Out)")
plt.ylabel("True Positive Rate (Recall)")
plt.title("Receiver Operating Characteristic (ROC) Curve")
plt.grid()
plt.savefig("resnet18_Receiver Operating Characteristic (ROC) Curve.png", bbox_inches="tight", dpi=300)
plt.show()

import torch

torch.save(model.state_dict(), 'Resnet_model.pt')